# A Service provider for managing HTTP Sessions
# in a Supranim application.
#
#   (c) 2025 George Lemon / Made by Humans from OpenPeeps
#   https://supranim.com | https://github.com/supranim
#   
#   Released under the MIT License.

import pkg/supranim/core/servicemanager
import pkg/libsodium/[sodium, sodium_sizes]

initService HttpSession[Singleton]:
  # config -> ConfigHttpSession
  backend do:
    import std/[times, strutils, json, tables, hashes]
    import pkg/supranim/support/[cookie, nanoid]
    export cookie

    type
      # Configuration Objects
      ConfigHttpAuthenticationResetPassword* = object
        enable: bool = true
          ## Whether to let user reset their password
        require_same_device: bool
          ## Require the user to be on the same device
          ## that they used to request the reset password link
        require_same_ip: bool
          ## Require the user to be on the same IP
          ## that they used to create the account.

      ConfigHttpAuthentication* = object
        enable_multiple_device_sessions*: bool = true
          ## Allow multiple devices to be authenticated
          ## using the same account at the same time.
        enable_remember_me*: bool = true
          ## Allow the user to check the `remember me`
          ## checkbox to keep them logged in.
        case enable_2fa: bool
          # Enable two factor authentication.
          of false: discard
          of true:
            discard # todo
        reset_password: ConfigHttpAuthenticationResetPassword
          ## Configuration for the reset password
          ## process. This is used to send a reset password
          ## email to the user.
      
      ConfigHttpRegistration* = object
        enable: bool = true
          # Whether to enable user registration
        error_message_prevent_enumeration: bool
          # Prevents user enumeration by returning the same
          # messages for most failed/success registration attempts.
      
      ConfigHttpSessionCookie* = object
        name: string = "ssid"
          # The name of the session cookie.
        domain: string = "127.0.0.1"
          # The domain of the session cookie.
        expiration: Option[DateTime] 
          # The expiration time of the session cookie.
          # if this is set to `none(DateTime)` the `ssid`
          # cookie will be a session-based cookie and it
          # will be deleted when the browser is closed.

      ConfigHttpSession* = object
        expiration: DateTime
        session_cookie: ConfigHttpSessionCookie
          # Configuration for the session cookie.
        authentication: ConfigHttpAuthentication
          # Configuration for the authentication process.
        registration: ConfigHttpRegistration
          # Configuration for the registration process.

      # Session
      Notification* = string
      CSRFFormIdentifier* = string
        # A unique identifier for the CSRF token.
        # This is used to identify the form that the
        # CSRF token is associated with. Usually
        # this is the form action URL.

      UserSessionType = enum
        sessionTypeDefault
          # A temporary session that will be
          # deleted after a certain time
        sessionTypeRememberMe
          # A session that will be preserved
          # until the user logs out or the session
          # is deleted by the server.

      UserSession* = ref object
        `type`: UserSessionType
        id: string
          # A unique NanoID that that represents the user session
          # the id can be regenerated by the server when the user session renews
          # (in case the session type is set as `sessionTypeRememberMe`)
        backend: CookiesTable = CookiesTable()
          # A `CookiesTable` for holding backend cookies.
        client: CookiesTable = CookiesTable()
          # A public `CookiesTable` for holding client cookies that will be
          # sent within the response.
        notifications: Table[string, seq[Notification]]
          # A table that holds flash bag notification messages.
          # This is useful for displaying notification messages
          # after a redirect, or a submitted form
        created, lastAccess: DateTime
        hasExpired: bool
          # Marks `UserSession` as expired before deleting it.
          # Expired sessions are cleared by the SessionCleaner
          # in a separate process
        payload: JsonNode
          # A JSON object that can be used to store
          # any payload related to the current user session.
        rememberToken: string
          # generated when user checks the `remember me`
          # checkbox to keep it logged in
        csrfSecretKey: string
          # a random string that is used to generate the CSRF
        csrfTokens: Table[CSRFFormIdentifier, string]
          # a table that holds the CSRF tokens for the session
          # this is used to validate the authenticity of the request

      Sessions = Table[string, UserSession]

      SessionStorageType = enum
        sessionDBStorage
        sessionFileStorage

      HttpSession = object
        keypair: string
        nonce: string
        storageType: SessionStorageType
        sessions: Sessions = Sessions()
      
      HttpSessionError* = object of CatchableError

    # forward declaration
    proc session*(): ptr HttpSession {.inline.}
    proc initSavedSessions*(instance: ptr HttpSession)

    proc newUserSession*(userData: JsonNode, reqPath: string): UserSession =
      ## Creates a new session object
      assert userData.kind == JObject
      var id: string
      let instance = session()
      while true:
        id = nanoid.generate(size = 42)
        if not instance.sessions.hasKey(id): break
      let createdAt = now()
      result = UserSession(
        id: id,
        created: createdAt,
        lastAccess: createdAt,
        csrfSecretKey: nanoid.generate(size = crypto_auth_hmacsha256_keybytes()),
        payload: userData
      )
      # result.backend["ssid"] = newCookie("ssid", $(userData), createdAt + 60.minutes)
      result.client["ssid"] = newCookie("ssid", id)
      instance.sessions[id] = result # store the user session

  client do:
    import pkg/[enimsql, jsony]
    from pkg/supranim/http/request import Request, getClientData, getUriPath
    from pkg/supranim/http/response import Response, addHeader
    from pkg/supranim/controller import getClientId, getSessionCookie

    proc session*(): ptr HttpSession {.inline.} =
      ## Returns the Singleton instance of HttpSession
      getHttpSessionInstance(
        proc(instance: ptr HttpSession) =
          {.gcsafe.}:
            initSavedSessions(instance)
      ) # `getHttpSessionInstance` auto generated by the service manager
  
    proc getUserSession*(req: var Request): UserSession =
      ## Returns the current user session.
      let ssid = req.getClientId()
      if ssid.isSome:
        let id = ssid.get() # the session id returned by the client
        let instance = session()
        if instance.sessions.hasKey(ssid.get()):
          return instance.sessions[ssid.get()]

    proc getId*(userSession: UserSession): string =
      ## Returns the session id
      result = userSession.id

    proc initSessionWithHeaders*(req: var Request, res: var Response): UserSession = 
      ## Initializes a new `UserSession` then adds a
      ## `set-cookie` header to the next `res` Response. 
      result = newUserSession(req.getClientData(), req.getUriPath())
      let userSessionCookie: ref Cookie = result.client["ssid"]
      if userSessionCookie != nil:
        # Add `set-cookie` header to the response
        res.addHeader("set-cookie", $userSessionCookie)
      else:
        raise newException(HttpSessionError, "Could not create a new Session")

    proc destroy*(userSession: UserSession, res: var Response) =
      ## Deletes the session object and overwrites the
      ## `set-cookie` header with an expired cookie.
      ## 
      ## This will delete the session cookie from backend and client
      let instance = session()
      defer:
        instance.sessions.del(userSession.id)
      var userCookie: ref Cookie = userSession.client["ssid"]
      assert userCookie != nil
      userCookie.expires()
      res.addHeader("set-cookie", $userCookie)
    
    proc checkAuthenticity*(userSession: UserSession, reqPayload: JsonNode): bool =
      for k, v in userSession.payload:
        if likely(reqPayload.hasKey(k)):
          if likely(hash(v.getStr()) == hash(reqPayload[k].getStr)):
            result = true
            continue # truthy. continue to check user data
          else: return false
        return false

    template withSession*(code) {.dirty.} =
      ## Template for executing a block of code
      ## that requires a user session.
      block:
        var userSession: UserSession = req.getUserSession()
        if userSession == nil: # init a new session
          userSession = initSessionWithHeaders(req, res)
        else:
          if not userSession.checkAuthenticity(req.getClientData()):
            userSession = initSessionWithHeaders(req, res)
        code

    template withUserSession*(code) {.dirty.} =
      ## Template for executing a block of code that requires a user session.
      ## This template can be used inside of a `controller`/`middleware` context
      block:
        let userSession: UserSession = req.getUserSession()
        if userSession != nil:
          code # execute code block

    proc isAuthenticated*(userSession: UserSession): bool =
      ## Determine if the user is authenticated by
      ## performing a database query to check if the session
      ## is valid.
      withDB do:
        result = userSession.payload != nil
        if result:
          let anySessions = Models.table("user_sessions").select
                                  .where("session_id", userSession.id).get()
          result = anySessions.isEmpty() == false
          if result:
            let storedSession = anySessions.first()
            let storedPayload = fromJson(storedSession.get("payload").value)
            for k, v in storedPayload:
              if likely(userSession.payload.hasKey(k)):
                if likely(hash(v.getStr) == hash(userSession.payload[k].getStr)):
                  continue # truthy. continue to check user data
                else: return false
              return false
    
    proc isAuthenticated*(req: var Request, res: var Response): bool =
      ## Determine if the user is authenticated by
      ## performing a database query to check if the session
      ## is valid.
      withSession do:
        result = userSession.isAuthenticated()

    proc getAuthUserId*(userSession: UserSession): Option[string] =
      ## Returns the user id based on the current session
      withDB do:
        if userSession.payload != nil:
          let anySessions = Models.table("user_sessions")
                                  .select("user_id")
                                  .where("session_id", userSession.id)
                                  .get()
          if not anySessions.isEmpty():
            return some(anySessions.first().get("user_id").value)
      none(string)

    proc getCreatedAt*(userSession: UserSession): DateTime =
      ## Returns the session created at time
      userSession.created

    proc initSavedSessions*(instance: ptr HttpSession) =
      ## Initializes the HttpSession service with saved sessions
      ## from the database.
      if instance[].storageType == sessionDBStorage:
        withDB do:
          let anySessions = Models.table("user_sessions").select.getAll()
          for s in anySessions:
            let payload = fromJson(s.get("payload").value)
            let id = s.get("session_id").value
            try:
              let createdAt = parse(s.get("created_at").value, "yyyy-MM-dd HH:mm:sszz")
              
              # if createdAt + instance.expiration <= now() and 
              #   # check if the session `createdAt` is expired
              #   # if expired, skip loading this session
              #   # todo the user_session db model should have a `last_access` field
              #   continue

              let userSession = UserSession(
                id: id,
                created: createdAt,
                lastAccess: createdAt,
                csrfSecretKey: nanoid.generate(size = crypto_auth_hmacsha256_keybytes()),
                payload: %*{
                  "ip": payload["ip"],
                  "platform": payload["platform"],
                  "agent": payload["agent"],
                  "sec-ch-ua": payload["sec-ch-ua"]
                }
              )
              userSession.client["ssid"] = newCookie("ssid", id)
              instance[].sessions[id] = userSession
            except TimeParseError as e:
              echo e.msg # todo log the error somewhere and
              continue

    #
    # Manage UserSession's payload
    #
    proc updatePayload*(userSession: UserSession, payload: JsonNode) =
      ## Updates the session payload
      userSession.payload = payload

    proc getPayload*(userSession: UserSession): JsonNode =
      ## Retrieve the session payload
      result = userSession.payload

    proc saveSession*(userSession: UserSession) =
      ## Saves the current session to the database.
      withDB do:
        Models.table("user_sessions").insert({
          "user_id": userSession.getAuthUserId().get(""),
          "session_id": userSession.getId(),
          "payload": toJson(userSession.getPayload()),
          "created_at": $(userSession.getCreatedAt())
        }).exec()

    #
    # CSRF handlers
    #
    proc genCSRF*(userSession: UserSession, id: string): string =
      ## Generates a new CSRF token.
      result = bin2hex(crypto_auth_hmacsha256(nanoid.generate(size = 8), userSession.csrfSecretKey))
      userSession.csrfTokens[id] = result

    proc validateCSRF*(userSession: UserSession, id, clientToken: string): bool =
      ## Validates the CSRF token
      if userSession.csrfTokens.hasKey(id) and userSession.csrfTokens[id] == clientToken:
        userSession.csrfTokens.del(id) # not needed anymore
        result = true

    #
    # Flash bag notifications
    #
    template notify*(userSession: UserSession, msg: string, somePath: Option[string] = none(string)) =
      ## Adds a flash message to the session. This message will be
      ## displayed in the next response. This is useful for displaying
      ## notification messages after a redirect.
      if userSession != nil:
        let path = if somePath.isSome: somePath.get() else: req.getUriPath()
        let ssid = userSession.getId
        let instance = session()
        if instance.sessions.hasKey(ssid):
          if not instance.sessions[ssid].notifications.hasKey(path):
            instance.sessions[ssid].notifications[path] = newSeq[Notification]()
          instance.sessions[ssid].notifications[path].add(msg)

    proc getNotifications*(userSession: UserSession, path: string): Option[seq[string]] =
      ## Returns available flash bag notifications.
      if userSession != nil:
        let ssid = userSession.getId
        let instance = session()
        if instance.sessions.hasKey(ssid):
          if instance.sessions[ssid].notifications.hasKey(path):
            defer:
              instance.sessions[ssid].notifications.del(path)
            return some(instance.sessions[ssid].notifications[path])
      none(seq[string])
